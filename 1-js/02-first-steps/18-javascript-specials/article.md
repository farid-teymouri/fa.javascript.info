# خلاصه‌ی فصل

در این قسمت به صورت خلاصه مباحثی را که تا به حال یاد گرفته‌ایم مرور می‌کنیم. این مباحث که شامل نحوه‌ی نوشتن دستورات، ساخت متغیّر، شرط، حلقه و تابع هستند اصول پایه‌ی زبان جاوااسکریپت را تشکیل می‌دهند. بعد از این فصل وارد مبحث اشیاء در جاوااسکریپت خواهیم شد.

## ساختار کد

دستورات (statementها) با ویرگول‌نقطه‌ی انگلیسی (;) از یکدیگر جدا می‌شوند.

```js run no-beautify
alert('Hello'); alert('World');
```

معمولاً همین که به خط بعدی می‌روید نیز به منزله‌ی جداسازی دستورات در نظر گرفته می‌شود، بنابراین این کد هم به درستی کار می‌کند:

```js run no-beautify
alert('Hello')
alert('World')
```

به این موضوع «درج خودکار ویرگول‌نقطه (automatic semicolon insertion)» گفته می‌شود. ولی گاهی اوقات درست کار نمی‌کند، مثل اینجا:

```js run
alert("There will be an error after this message")

[1, 2].forEach(alert)
```

در بیشتر سبک‌های کدنویسی پیشنهاد شده است که حتماً بعد از هر دستور ویر‌گول‌نقطه گذاشته شود.

لازم نیست بعد از بلاک‌های کد {...} و ساختارهایی که با این بلاک‌ها ساخته می‌شوند، مثل حلقه‌ها ویرگول‌نقطه قرار دهید.

```js
function f() {
  // بعد از ساخت تابع، نیازی به ویرگول‌نقطه نیست.
}

for(;;) {
  // بعد از حلقه نیازی نیست ویرگول‌نقطه بگذارید.
}
```

ولی با این حال اگر ویرگول‌نقطه‌ی اضافی در کد خود بنویسید مشکلی ایجاد نمی‌کند و نادیده گرفته می‌شود.

برای اطّلاعات بیشتر اینجا را ببینید <info:structure>.

## حالت Strict

برای اینکه تمام قابلیّت‌های مدرن جاوااسکریپت فعّال شود لازم است که فایل جاوااسکریپت خود را با عبارت`"use strict"` شروع کنیم:

```js
'use strict';

...
```

این دستور می‌تواند در ابتدای یک فایل جاوااسکریپت یا ابتدای یک تابع نوشته شود.

بدون نوشتن `"use strict"` هم کد ما کار می‌کند، ولی بعضی چیزها در حالت قدیمی خود عمل می‌کنند. ما معمولاً رفتار مدرن آن‌ها را ترجیح می‌دهیم.

بعضی از ویژگی‌های مدرن جاوااسکریپت (مثل کلاس‌ها که بعداً به آن می‌رسیم) به صورت خودکار و بدون اینکه نیازی باشد `"use strict"` را بنویسیم کد را در حالت strict اجرا می‌کنند.

برای اطلاعات بیشتر اینجا را ببینید: <info:strict-mode>.

## متغیّرها (Variables)

می‌تواند به شکل‌های زیر ساخته شود:

- `let`
- `const` (ثابت، نمی‌توان مقدارش را تغییر داد)
- `var` (سبک قدیمی، که بعداً تفاوت‌هایش را می‌بینیم)

نام متغیّر می‌تواند شامل این موارد باشد:

حروف و ارقام، ولی اوّلین کاراکتر نمی‌تواند رقم باشد- .
کاراکترهای $ و _ هم مثل سایر حروف الفبا مجاز هستند- .
حروف الفبای غیر انگلیسی و حروف تصویری هم مجاز هستند، ولی معمولاً استفاده نمی‌شوند- .

نوع متغیّر پویا است و هر نوع مقداری را می‌توان در آن نگهداری کرد:

```js
let x = 5;
x = "John";
```

۷ نوع داده وجود دارد:
عدد-  (number) برای اعداد اعشاری و اعداد صحیح.
رشته- (string) برای متن‌ها
بولین-  (boolean) برای نشان دادن مقادیر منطقی true/false
- null: نوعی که فقط دارای مقدار خاص null است و نشان‌دهنده‌ی خالی بودن یا وجود نداشتن است.
- undefined: نوعی که فقط دارای مقدار خاص undefined است و نشان‌دهنده‌ی این است که چیزی نسبت داده نشده است.
شیء-  (object): برای ساختارهای اطّلاعاتی پیچیده (بعداً در مورد این نوع صحبت خواهیم کرد).
نماد-  (symbol): برای شناسه‌های منحصر به فرد (بعداً در مورد این نوع صحبت خواهیم کرد).

عملگر `typeof` نوع هر مقداری را در قالب یک رشته به ما بر می‌گرداند با دو استثناء:
```js
typeof null == "object" // اشتباهی در زبان جاوااسکریپت
typeof function(){} == "function" // تابع‌ها در اصل زیرمجموعه‌ای از اشیاء هستند
```

برای اطلاعات بیشتر <info:variables> و <info:types> را ببینید

## تعامل

ما از مرورگر به عنوان محیط کار خود استفاده می‌کنیم، در این محیط چند تابع برای ارتباط با کاربر وجود دارد:

[`prompt(question)`](mdn:api/Window/prompt)
پیامی را به کاربر نمایش می‌دهد که از او می‌خواهد متنی را تایپ کند. بعد متن تایپ شده را بر می‌گرداند. در صورتی که کاربر روی: cancel کلیک کند یا کلید Esc را فشار دهد مقدار null را بر می‌گرداند.

[`confirm(question)`](mdn:api/Window/confirm)
پیامی را نشان می‌دهد و منتظر می‌ماند تا کاربر روی دکمه‌ی: cancel یا ok کلیک کند. در صورت کلیک روی ok مقدار true و در صورت کلیک روی cancel یا زدن Esc مقدار false را بر می‌گرداند.

[`alert`](mdn:api/Window/alert)
پیامی را به کاربر نمایش می‌دهد:.

این سه تابع modal هستند: به این معنا که به اجرای کد جاوااسکریپت را متوقّف می‌کنند و به کاربر اجازه نمی‌دهند که با بقیّه‌ی صفحه تعامل داشته باشد و کار کند، تا اینکه این کادرها بسته شوند. این ویژگی با طبیعت زبان جاوااسکریپت زیاد سازگار نیست، به همین دلیل سازندگان مرورگرها (به خصوص کروم) توصیه می‌کنند از روش‌های دیگری غیر از این‌ها استفاده شود و محدودیت‌هایی نیز به وجود آورده‌اند (مثلاً در کروم حتماً باید همان سربرگی که می‌خواهد این modalها را نمایش دهد در حالت focus باشد و…). ولی به دلیل سادگی این روش و سخت‌تر بودن روش‌های جایگزین، در این آموزش ما همیشه از همین‌ها استفاده می‌کنیم.

مثال:

```js run
let userName = prompt("Your name?", "Alice");
let isTeaWanted = confirm("Do you want some tea?");

alert( "Visitor: " + userName ); // Alice
alert( "Tea wanted: " + isTeaWanted ); // true
```

اطلاعات بیشتر در: <info:alert-prompt-confirm>.

## عملگرها

جاوااسکریپت از عملگرهای زیر پشتیبانی می‌کند:

عملگرهای محاسباتی
: عملگرهای عادی: `* + - /`, و نیز `%` برای محاسبه‌ی باقیمانده‌ی تقسیم و `**` برای به توان رساندن اعداد.

عملگر دودویی + رشته‌ها را به هم وصل می‌کند. و اگر یکی از دو طرف این عملگر از نوع رشته باشد، طرف دیگر به صورت خودکار به رشته تبدیل می‌شود.

    ```js run
    alert( '1' + 2 ); // '12', string
    alert( 1 + '2' ); // '12', string
    ```

انتساب
دو نوع انتساب داریم: انتساب معمولی مثل: a = b و انتساب ترکیبی مثل a *= 2.

بیتی (bitwise)
عملگرهای بیتی با اعداد صحیح در سطح بیتی (مبنای ۲) کار می‌کنند (و زیاد کاربرد ندارند:). اگر علاقه دارید در مورد این نوع عملگرها بیشتر بدانید به [مستندات موزیلا](mdn:/JavaScript/Reference/Operators/Bitwise_Operators) مراجعه کنید.

سه‌تایی (ternary)
تنها عملگری است که سه پارامتر می‌گیرد:: cond ? resultA : result اگر cond مقداری truthy باشد (در تبدیل به بولین معادل true باشد)، مقدار resultA را بر می‌گرداند، در غیر این صورت resultB.

عملگرهای منطقی (logical)
عملگر «و» (&&): در صورتی که طرف چپ: falsy باشد همان را بر می‌گرداند و در غیر این صورت طرف راست را بر می‌گرداند (در صورت اوّل کلاً طرف راست بررسی نخواهد شد که truthy است یا falsy).

عملگر «یا» (||): در صورتی که طرف چپ truthy باشد همان را بر می‌گرداند و در غیر این صورت طرف راست را بر می‌گرداند (در صورت اوّل کلاً طرف راست بررسی نخواهد شد که truthy است یا falsy).

عملگرهای مقایسه‌ای
کوچکتر (<)، بزرگتر (>)، کوچکتر یا مساوی (<=)، بزرگتر یا مساوی (>=)، نامساوی (!=) و:…

عملگر بررسی تساوی (==) برای مقادیری که نوع متفاوتی از یکدیگر دارند، هر دو را به نوع عدد تبدیل می‌کند (به استثنای null و undefined که این دو با هم برابرند و با هیچ چیز دیگر برابر نیستند).

<<<<<<< HEAD:1-js/02-first-steps/17-javascript-specials/article.md
=======
Nullish coalescing operator
: The `??` operator provides a way to choose a defined value from a list of variables. The result of `a ?? b` is `a` unless it's `null/undefined`, then `b`.

Comparisons
: Equality check `==` for values of different types converts them to a number (except `null` and `undefined` that equal each other and nothing else), so these are equal:
>>>>>>> cd2c7ce3c8f033e6f7861ed1b126552e41ba3e31:1-js/02-first-steps/18-javascript-specials/article.md

    ```js run
    alert( 0 == false ); // true
    alert( 0 == '' ); // true
    ```

سایر عملگرهای مقایسه‌ای هر دو طرف را تبدیل به عدد می‌کنند.

عملگر مساوی سه‌تایی `===` تبدیل نوع انجام نمی‌دهد، و اگر نوع دو طرف یکسان نباشد، قطعاً با یکدیگر برابر در نظر گرفته نخواهند شد

مقادیر null و undefined خاص هستند. این دو مقدار با هم مساوی در نظر گرفته می‌شوند و با هیچ چیز دیگری مساوی نیستند.

عملگرهای کوچکتر/بزرگتر رشته‌ها را کاراکتر به کاراکتر به ترتیب حروف الفبا مقایسه می‌کنند، و بقیه‌ی نوع‌ها را به عدد تبدیل می‌کنند.

سایر عملگرها
عملگرهای دیگری مثل ویرگول انگلیسی (,) و غیره نیز در زبان جاوااسکریپت وجود دارند.

<<<<<<< HEAD:1-js/02-first-steps/17-javascript-specials/article.md
اطّلاعات بیشتر در: <info:operators>، <info:comparison>، <info:logical-operators>.
=======
More in: <info:operators>, <info:comparison>, <info:logical-operators>, <info:nullish-coalescing-operator>.
>>>>>>> cd2c7ce3c8f033e6f7861ed1b126552e41ba3e31:1-js/02-first-steps/18-javascript-specials/article.md

## حلقه‌ها

- تا به حال با ۳ نوع حلقه آشنا شدیم:

    ```js
    // 1
    while (condition) {
      ...
    }

    // 2
    do {
      ...
    } while (condition);

    // 3
    for(let i = 0; i < 10; i++) {
      ...
    }
    ```

- متغیّری که درون for(let...)  ساخته می‌شود فقط در درون خود حلقه دیده می‌شود و قابل استفاده است. البته شما می‌توانید کلمه‌ی let را از اینجا حذف کنید تا از یکی از متغیّرهایی که از قبل ساخته‌اید استفاده کنید.
- دستور break برای متوقّف کردن و خروج از کلّ حلقه و دستور continue برای خروج از دور فعلی حلقه استفاده می‌شود. برای خروج از حلقه‌های تودرتو می‌توانید از برچسب (label) استفاده کنید.

[جزئیات بیشتر را در: <info:while-for> .مطالعه کنید

بعداً که با اشیاء آشنا شویم چند مدل حلقه‌ی دیگر را نیز در جاوااسکریپت می‌آموزیم.

## ساختار switch

ساختار switch می‌تواند جایگزین چند بررسی از طریق if بشود. در این ساختار به صورت خودکار از === برای مقایسه‌ها استفاده می‌شود.

برای مثال:

```js run
let age = prompt('Your age?', 18);

switch (age) {
  case 18:
<<<<<<< HEAD:1-js/02-first-steps/17-javascript-specials/article.md
    alert("Won't work"); // نتیجه عدد نیست، بلکه رشته است
=======
    alert("Won't work"); // the result of prompt is a string, not a number
    break;
>>>>>>> cd2c7ce3c8f033e6f7861ed1b126552e41ba3e31:1-js/02-first-steps/18-javascript-specials/article.md

  case "18":
    alert("This works!");
    break;

  default:
    alert("Any value not equal to one above");
}
```

جزئیات بیشتر را در <info:switch> مطالعه کنید.

## تابع‌ها (functions)

ما تا به حال با سه روش برای ساخت تابع‌ها آشنا شدیم:

۱. اعلام تابع (function declaration):

    ```js
    function sum(a, b) {
      let result = a + b;

      return result;
    }
    ```

۲. عبارت تابعی (function expression):

    ```js
    let sum = function(a, b) {
      let result = a + b;

      return result;
    };
    ```

۳. تابع پیکانی (Arrow function)

    ```js
    // :عبارتی در سمت راست که همان بر می‌گردد
    let sum = (a, b) => a + b;

    // یا مدل چند خطّی با {...}، که در این حالت باید return :هم بنویسید
    let sum = (a, b) => {
      // ...
      return a + b;
    }

    // بدون آرگومان ورودی
    let sayHi = () => alert("Hello");

    // فقط یک آرگومان
    let double = n => n * 2;
    ```


- تابع‌ها می‌توانند دارای متغیّرهایی باشند که داخل خود تابع ساخته می‌شوند که به آن‌ها متغیّرهای محلّی می‌گوییم و این گونه متغیّرها فقط در داخل خود تابع دیده می‌شوند و فقط در آن‌جا به آن‌ها دسترسی داریم.
- پارامترهای ورودی تابع می‌توانند مقدار پیش‌فرض بپذیرند: `function sum(a = 1, b = 2) {...}`
- تابع‌ها همیشه چیزی را بر می‌گردانند. اگر داخل تابع اصلاً از دستور return استفاده نشده باشد، نتیجه می‌شود undefined.

برای مشاهده‌ی جزئیات بیشتر <info:function-basics> و <info:function-expressions-arrows> را ببینید.

## هنوز خیلی مطلب باقی مانده است

موارد فوق تنها خلاصه‌ای از قابلیت‌های جاوااسکریپت بود. تا الآن فقط مبانی این زبان را یاد گرفته‌ایم. در ادامه باقابلیت‌ها و ویژگی‌های حرفه‌ای جاوااسکریپت آشنا خواهیم شد.

